**冒泡排序**  
1) 冒泡排序的过程  
a. 在arr[0~N-1]的范围上,arr[0]与arr[1]比较,谁大谁来到1的位置,
   arr[1]与arr[2]比较,谁大谁来到2的位置......,arr[N-2]与arr[N-1]比较,谁大谁来到N-1的位置,
   做完整个过程,肯定最大的数已经来到了最右边。  
b. 在arr[0~N-2]的范围上,重复上述过程，最后一步是arr[N-3]与arr[N-2]比较，谁大谁来到N-2的位置。     
c. 在arr[0~N-3]的范围上,重复上述过程，最后一步是arr[N-4]与arr[N-3]比较，谁大谁来到N-3的位置。  
    ......  
n. 最后一步在arr[0-1]的范围上，arr[0]与arr[1]比较，谁大谁来到1的位置。至此整个数组有序    
   

2) 时间复杂度估算  
   如果arr长度为N，每一步常数操作的数量，依然如等差数列一般 所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)
   
    所以冒泡排序的时间复杂度为O(N^2)。
   

3) java实现  
   com.algorithm.sort.Bubble.bubble

**选择排序**  
1) 选择排序的过程   
   a. arr[0～N-1]范围上，找到最小值所在的位置，然后把最小值交换到0位置。  
   b. arr[1～N-1]范围上，找到最小值所在的位置，然后把最小值交换到1位置。  
   c. arr[2～N-1]范围上，找到最小值所在的位置，然后把最小值交换到2位置。  
   ......  
   n. arr[N-1～N-1]范围上，找到最小值位置，然后把最小值交换到N-1位置。 
   

2) 时间复杂度 O(N^2)


3) 实现  
   com.algorithm.sort.Select.select

**插入排序**
1) 插入排序的过程   
   a. 想让arr[0~0]上有序，这个范围只有一个数，当然是有序的。  
   b. 想让arr[0~1]上有序，所以从arr[1]开始往前看，如果arr[1]<arr[0]，就交换。否则什么也不做。
   ......   
   c. 想让arr[0~i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。  
   d. 最后一步，想让arr[0~N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。



2) 时间复杂度 O(N^2)  
   如果某个算法流程的复杂程度会根据数据状况的不同而不同，那么你必须要按照最差情况来估计。  
   很明显，在最差情况下，如果arr长度为N，插入排序的每一步常数操作的数量，还是如等差数列一般   
   所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)  

所以插入排序排序的时间复杂度为O(N^2)。


3) 实现  
   com.algorithm.sort.Insert.insertSort